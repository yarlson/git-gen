#!/bin/bash

# ANSI color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

JIRA_TICKET_REGEX='[A-Z]+-[0-9]+'

# Check if in a git repository
if ! REPO_DIR=$(git rev-parse --show-toplevel 2>/dev/null); then
    echo -e "${RED}Not a git repository.${NC}"
    exit 1
fi

cd "$REPO_DIR" || exit 1

BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)

# Extract Jira ticket ID from branch name
JIRA_TICKET=$(echo "${BRANCH_NAME##*/}" | grep -oE "$JIRA_TICKET_REGEX")

# Add all changes to the index
git add .

# Get lists of changed files
ADDED_FILES=$(git diff --cached --name-only --diff-filter=A)
DELETED_FILES=$(git diff --cached --name-only --diff-filter=D)
MODIFIED_FILES=$(git diff --cached --name-only --diff-filter=M)

# Get current diff
DIFF=$(git diff --cached)

# Get last 10 commit messages
LAST_10_COMMITS=$(git log -n 10 --pretty=format:"%s")

generate_commit_message() {
    local payload
    payload=$(jq -n \
        --arg diff "$DIFF" \
        --arg addedFiles "$ADDED_FILES" \
        --arg deletedFiles "$DELETED_FILES" \
        --arg modifiedFiles "$MODIFIED_FILES" \
        --arg lastCommits "$LAST_10_COMMITS" \
        '{
            "model": "gpt-4o",
            "messages": [
                {
                    "role": "system",
                    "content": "You are a helpful assistant tasked with generating concise and informative commit messages. Analyze the provided list of added, deleted, and modified files along with the diff details and previous commit messages. Based on this information, create a commit message that summarizes the changes effectively and maintains consistency with the project'"'"'s commit history."
                },
                {
                    "role": "user",
                    "content": ("Generate a short commit message for these changes, do not include a list of added, updated or deleted files, do not describe the commit message, provide only commit message itself, in the commit message describe only business logic, not implementation details, use imperative mood, emphasizing the essence of the message. Consider the following previous commit messages for consistency:\n" + $lastCommits + "\n\nAdded files:\n" + $addedFiles + "\nDeleted files:\n" + $deletedFiles + "\nModified files:\n" + $modifiedFiles + "\n\n```\n" + $diff + "\n```")
                }
            ]
        }')

    curl -s -X POST \
        https://api.openai.com/v1/chat/completions \
        -H "Authorization: Bearer $OPENAI_API_KEY" \
        -H "Content-Type: application/json" \
        -d "$payload" | jq -r '.choices[0].message.content'
}

while true; do
    MESSAGE=$(generate_commit_message)

    if [ -z "$MESSAGE" ]; then
        echo -e "${RED}Failed to generate commit message${NC}"
        exit 1
    fi

    # Prepend Jira ticket ID if present
    [ -n "$JIRA_TICKET" ] && MESSAGE="$JIRA_TICKET $MESSAGE"

    echo -e "${YELLOW}Generated commit message: ${NC}$MESSAGE"
    echo -ne "${PURPLE}Is this commit message ok? (y/n/e for edit): ${NC}"
    read -r CONFIRMATION

    case $CONFIRMATION in
        y) break ;;
        n) continue ;;
        e)
            echo "$MESSAGE" > temp_commit_message.txt
            ${EDITOR:-vim} temp_commit_message.txt
            MESSAGE=$(<temp_commit_message.txt)
            rm temp_commit_message.txt
            break
            ;;
    esac
done

# Commit changes with the generated message
git commit -m "$MESSAGE"
echo -e "${GREEN}Changes committed${NC}"
